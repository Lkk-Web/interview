---
group:
  # title: '运维'
  order: 4
order: 1
---

# Shell/Bash

<!-- 参考文档：【阮一峰】https://wangdoc.com/bash/intro.html -->

# 一、简介

## 1、Shell 的含义

学习 Bash，首先需要理解 Shell 是什么。首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（command line interface，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。

最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。

Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。

## 2、命令行环境

### 终端模拟器

所谓“终端模拟器”（terminal emulator）就是一个模拟命令行窗口的程序，不同 Linux 发行版（准确地说是不同的桌面环境）带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。

完整的提示符是`[username@hostname] $`，其中前缀是用户名（`username`）加上`@`，再加主机名（`hostname`）。比如，用户名是`bill`，主机名是`home-machine`，前缀就是`bill@home-machine`。

```bash
[user@hostname] $
```

## 3、进入和退出方法

如果你的 Shell 不是 Bash，可以输入`bash`命令启动 Bash。

```bash
$ bash
```

退出 Bash 环境，可以使用`exit`命令，也可以同时按下`Ctrl + d`。

```bash
$ exit
```

Bash 的基本用法就是在命令行输入各种命令，非常直观。作为练习，可以试着输入`pwd`命令。按下回车键，就会显示当前所在的目录。

```bash
$ pwd
/home/me
```

# 二、基本语法

## 1、echo 命令

由于后面的例子会大量用到`echo`命令，这里先介绍这个命令。

`echo`命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。

```bash
$ echo hello world
hello world
```

上面例子中，`echo`的参数是`hello world`，可以原样输出。

如果想要输出的是多行文本，即包括换行符。这时就需要把多行文本放在引号里面。

```bash
$ echo "<HTML>
    <HEAD>
          <TITLE>Page Title</TITLE>
    </HEAD>
    <BODY>
          Page body.
    </BODY>
</HTML>"
```

上面例子中，`echo`可以原样输出多行文本。

### 1.1、`-n`参数

默认情况下，`echo`输出的文本末尾会有一个回车符。`-n`参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。

```
$ echo a;echo b
a
b

$ echo -n a;echo b
ab
```

上面例子中，`-n`参数可以让两个`echo`命令的输出连在一起，出现在同一行。

### 1.2、`-e`参数

`-e`参数会解释引号（双引号和单引号）里面的特殊字符（比如换行符`\n`）。如果不使用`-e`参数，即默认情况下，引号会让特殊字符变成普通字符，`echo`不解释它们，原样输出。

```
$ echo hello\nworld
hellonworld

$ echo "Hello\nWorld"
Hello\nWorld

# 引号的情况
$ echo -e "Hello\nWorld"
Hello
World
```

上面代码中，`-e`参数使得`\n`解释为换行符，导致输出内容里面出现换行。

## 2、命令格式

命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。

```
$ command [ arg1 ... [ argN ]]
```

上面代码中，`command`是具体的命令或者一个可执行文件，`arg1 ... argN`是传递给命令的参数，它们是可选的。

有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的`-l`。同一个配置项往往有长和短两种形式，下面命令中，`-r`是短形式，`--reverse`是长形式，作用完全一样。前者便于输入，后者便于理解。

```
# 短形式
$ ls -r

# 长形式
$ ls --reverse
```

有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。

```
$ echo foo bar

# 等同于
$ echo foo \
bar
```

## 3、空格

Bash 使用空格（或 Tab 键）区分不同的参数。

```
$ command foo bar
```

上面命令中，`foo`和`bar`之间有一个空格，所以 Bash 认为它们是两个参数。

如果参数之间有多个空格，Bash 会自动忽略多余的空格。

```
$ echo this is a     test
this is a test
```

上面命令中，`a`和`test`之间有多个空格，Bash 会忽略多余的空格。

## 4、分号

分号（`;`）是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后不管成功或失败，都会继续执行第二个命令。

```
$ clear; ls
```

上面例子中，Bash 先执行`clear`命令，执行完成后，再执行`ls`命令。

注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。

## 5、命令的组合符`&&`和`||`

除了分号，Bash 还提供两个命令组合符`&&`和`||`，允许更好地控制多个命令之间的继发关系。

```
Command1 && Command2
```

上面命令的意思是，如果`Command1`命令运行成功，则继续运行`Command2`命令。

```
Command1 || Command2
```

上面命令的意思是，如果`Command1`命令运行失败，则继续运行`Command2`命令。

## 6、type 命令

Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢？

`type`命令用来判断命令的来源。

```
$ type echo
echo is a shell builtin
$ type ls
ls is hashed (/bin/ls)
```

上面代码中，`type`命令告诉我们，`echo`是内部命令，`ls`是外部程序（`/bin/ls`）。

如果要查看一个命令的所有定义，可以使用`type`命令的`-a`参数。

```
$ type -a echo
echo is shell builtin
echo is /usr/bin/echo
echo is /bin/echo
```

上面代码表示，`echo`命令既是内置命令，也有对应的外部程序。

`type`命令的`-t`参数，可以返回一个命令的类型：别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file）。

```
$ type -t bash
file
$ type -t if
keyword
```

上面例子中，`bash`是文件，`if`是关键词。

## 7、快捷键

- `Ctrl + L`：清除屏幕并将当前行移到页面顶部。
- `Ctrl + C`：中止当前正在执行的命令。
- `Shift + PageUp`：向上滚动。
- `Shift + PageDown`：向下滚动。
- `Ctrl + U`：从光标位置删除到行首。
- `Ctrl + K`：从光标位置删除到行尾。
- `Ctrl + D`：关闭 Shell 会话。
- `↑`，`↓`：浏览已执行命令的历史记录。

除了上面的快捷键，Bash 还具有自动补全功能。除了命令的自动补全，Bash 还支持路径的自动补全，如果有多个可能的选择，按两次 Tab 键，Bash 会显示所有选项，让你选择。

# 三、Bash 的模式扩展

## 1、简介

特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。

Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。

模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。

- 波浪线扩展
- `?` 字符扩展
- `*` 字符扩展
- 方括号扩展
- 大括号扩展
- 变量扩展
- 子命令扩展
- 算术扩展

## 2、波浪线扩展

波浪线`~`会自动扩展成当前用户的主目录。

```
$ echo ~
/home/me
```

`~/dir`表示扩展成主目录的某个子目录，`dir`是主目录里面的一个子目录名。

```
# 进入 /home/me/foo 目录
$ cd ~/foo
```

`~+`会扩展成当前所在的目录，等同于`pwd`命令。

```
$ cd ~/foo
$ echo ~+
/home/me/foo
```

## 3、`?` 字符扩展

`Data???`匹配所有`Data`后面跟着三个字符的文件名。

```
# 存在文件 a.txt 和 b.txt
$ ls ?.txt
a.txt b.txt
```

上面命令中，`?`表示单个字符，所以会同时匹配`a.txt`和`b.txt`。

如果匹配多个字符，就需要多个`?`连用。

```
# 存在文件 a.txt、b.txt 和 ab.txt
$ ls ??.txt
ab.txt
```

上面命令中，`??`匹配了两个字符。

`?` 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。

```
# 当前目录有 a.txt 文件
$ echo ?.txt
a.txt
```

## 4、`*` 字符扩展

`*`字符代表文件路径里面的任意数量的任意字符，包括零个字符。

如果想输出当前目录的所有文件，直接用`*`即可。

```
$ ls *
```

`*`可以匹配空字符，下面是一个例子。

```
# 存在文件 a.txt、b.txt 和 ab.txt
$ ls a*.txt
a.txt ab.txt
```

注意，`*`不会匹配隐藏文件（以`.`开头的文件），即`ls *`不会输出隐藏文件。

如果要匹配隐藏文件，需要写成`.*`。

```
# 显示所有隐藏文件
$ echo .*
```

如果要匹配隐藏文件，同时要排除`.`和`..`这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成`.[!.]*`。

```
$ echo .[!.]*
```

## 5、方括号扩展

方括号扩展的形式是`[...]`，括号之中的任意一个字符。比如，`[aeiou]`可以匹配五个元音字母中的任意一个。

```
# 存在文件 a.txt 和 b.txt
$ ls [ab].txt
a.txt b.txt
```

上面例子中，`[ab]`可以匹配`a`或`b`，前提是确实存在相应的文件。

方括号扩展还有两种变体：`[^...]`和`[!...]`。它们表示匹配不在方括号里面的字符，这两种写法是等价的。

注意，如果需要匹配`[`字符，可以放在方括号内，比如`[[aeiou]`。如果需要匹配连字号`-`，只能放在方括号内部的开头或结尾，比如`[-aeiou]`或`[aeiou-]`。

## 6、[start-end] 扩展

方括号扩展有一个简写形式`[start-end]`，表示匹配一个连续的范围。比如，`[a-c]`等同于`[abc]`，`[0-9]`匹配`[0123456789]`。

下面是一些常用简写的例子。

- `[a-z]`：所有小写字母。
- `[a-zA-Z]`：所有小写字母与大写字母。
- `[a-zA-Z0-9]`：所有小写字母、大写字母与数字。
- `[abc]*`：所有以`a`、`b`、`c`字符之一开头的文件名。
- `program.[co]`：文件`program.c`与文件`program.o`。
- `BACKUP.[0-9][0-9][0-9]`：所有以`BACKUP.`开头，后面是三个数字的文件名。

这种简写形式有一个否定形式`[!start-end]`，表示匹配不属于这个范围的字符。

## 7、大括号扩展

大括号扩展`{...}`表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，`{1,2,3}`扩展成`1 2 3`。

另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。

```bash
$ echo {1,2,3}
1 2 3

$ echo d{a,e,i,u,o}g
dag deg dig dug dog

$ echo {1 , 2}
{1 , 2}
```

## 8、{start..end} 扩展

大括号扩展有一个简写形式`{start..end}`，表示扩展成一个连续序列。比如，`{a..z}`可以扩展成 26 个小写英文字母。

```
$ echo {a..c}
a b c
```

这种简写形式支持逆序。

```
$ echo {c..a}
c b a

$ echo {5..1}
5 4 3 2 1
```

注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。

```
$ echo {a1..3c}
{a1..3c}
```

大括号扩展的常见用途为新建一系列目录。

```
$ mkdir {2007..2009}-{01..12}
```

上面命令会新建 36 个子目录，每个子目录的名字都是”年份-月份“。

这个写法的另一个常见用途，是直接用于`for`循环。

```
for i in {1..4}
do
  echo $i
done
```

上面例子会循环 4 次。

如果整数前面有前导`0`，扩展输出的每一项都有前导`0`。

```
$ echo {01..5}
01 02 03 04 05

$ echo {001..5}
001 002 003 004 005
```

这种简写形式还可以使用第二个双点号（`start..end..step`），用来指定扩展的步长。

```
$ echo {0..8..2}
0 2 4 6 8
```

上面代码将`0`扩展到`8`，每次递增的长度为`2`，所以一共输出 5 个数字。

多个简写形式连用，会有循环处理的效果。

```
$ echo {a..c}{1..3}
a1 a2 a3 b1 b2 b3 c1 c2 c3
```

## 9、变量扩展

`$(...)`可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。

```
$ echo $(date)
Tue Jan 28 00:01:13 CST 2020
```

还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。

```
$ echo `date`
Tue Jan 28 00:01:13 CST 2020
```

# 四、数据类型

Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。

## 1、转义

某些字符在 Bash 里面有特殊含义（比如`$`、`&`、`*`）。

如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”（escape）。

```
$ echo \$date
$date
```

上面命令中，只有在特殊字符`$`前面加反斜杠，才能原样输出。

反斜杠本身也是特殊字符，如果想要原样输出反斜杠，就需要对它自身转义，连续使用两个反斜线（`\\`）。

```
$ echo \\
\
```

上面例子输出了反斜杠本身。

反斜杠除了用于转义，还可以表示一些不可打印的字符。

- `\a`：响铃
- `\b`：退格
- `\n`：换行
- `\r`：回车
- `\t`：制表符

如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用`echo`命令的`-e`参数。

```
$ echo a\tb
atb

$ echo -e "a\tb"
a        b
```

上面例子中，命令行直接输出不可打印字符`\t`，Bash 不能正确解释。必须把它们放在引号之中，然后使用`echo`命令的`-e`参数。

## 2、单引号

Bash 允许字符串放在单引号或双引号之中，加以引用。

单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（`*`）、美元符号（`$`）、反斜杠（`\`）等。

## 3、双引号

双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通字符。

```
$ echo "*"
*
```

但是，三个特殊字符除外：美元符号（`$`）、反引号（```）和反斜杠（`\）。这三个字符在双引号之中，依然有特殊含义，会被 Bash 自动扩展。

换行符在双引号之中，会失去特殊含义，Bash 不再将其解释为命令的结束，只是作为普通的换行符。所以可以利用双引号，在命令行输入多行文本。

```
$ echo "hello
world"
hello
world
```

双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号（或单引号），将文件名放在里面。

```
$ ls "two words.txt"
```

## 4、Here 文档

Here 文档（here document）是一种输入多行字符串的方法，格式如下。

```
<< token
text
token
```

它的格式分成开始标记（`<< token`）和结束标记（`token`）。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。

下面是一个通过 Here 文档输出 HTML 代码的例子。

```
$ cat << _EOF_
<html>
<head>
    <title>
    The title of your page
    </title>
</head>

<body>
    Your page content goes here.
</body>
</html>
_EOF_
```

Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。

```
$ foo='hello world'
$ cat << _example_
$foo
"$foo"
'$foo'
_example_

hello world
"hello world"
'hello world'
```

上面例子中，变量`$foo`发生了替换，但是双引号和单引号都原样输出了，表明它们已经失去了引用的功能。

如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。

```
$ foo='hello world'
$ cat << '_example_'
$foo
"$foo"
'$foo'
_example_

$foo
"$foo"
'$foo'
```

上面例子中，Here 文档的开始标记（`_example_`）放在单引号之中，导致变量替换失效了。

Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了`echo`命令。

```
$ command << token
  string
token

# 等同于

$ echo string | command
```

上面代码中，Here 文档相当于`echo`命令的重定向。

所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如`echo`命令就不能用 Here 文档作为参数。

```
$ echo << _example_
hello
_example_
```

上面例子不会有任何输出，因为 Here 文档对于`echo`命令无效。

此外，Here 文档也不能作为变量的值，只能用于命令的参数。

# 五、Bash 变量

## 1、简介

Bash 变量分成环境变量和自定义变量两类。

### 1.1、环境变量

环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。

`env`命令或`printenv`命令，可以显示所有环境变量。

```
$ env
```

下面是一些常见的环境变量。

- `BASHPID`：Bash 进程的进程 ID。
- `BASHOPTS`：当前 Shell 的参数，可以用`shopt`命令修改。
- `DISPLAY`：图形环境的显示器名字，通常是`:0`，表示 X Server 的第一个显示器。
- `EDITOR`：默认的文本编辑器。
- `HOME`：用户的主目录。
- `HOST`：当前主机的名称。
- `IFS`：词与词之间的分隔符，默认为空格。
- `LANG`：字符集以及语言编码，比如`zh_CN.UTF-8`。
- `PATH`：由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。
- `PS1`：Shell 提示符。
- `PS2`： 输入多行命令时，次要的 Shell 提示符。
- `PWD`：当前工作目录。
- `RANDOM`：返回一个 0 到 32767 之间的随机数。
- `SHELL`：Shell 的名字。
- `SHELLOPTS`：启动当前 Shell 的`set`命令的参数，参见《set 命令》一章。
- `TERM`：终端类型名，即终端仿真器所用的协议。
- `UID`：当前用户的 ID 编号。
- `USER`：当前用户的用户名。

很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。

注意，Bash 变量名区分大小写，`HOME`和`home`是两个不同的变量。

查看单个环境变量的值，可以使用`printenv`命令或`echo`命令。

```
$ printenv PATH
# 或者
$ echo $PATH
```

注意，`printenv`命令后面的变量名，不用加前缀`$`。

### 1.2、自定义变量

自定义变量是用户在当前 Shell 里面自己定义的变量，仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。

`set`命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。

```
$ set
```

## 2、创建变量

变量声明的语法如下。

```
variable=value
```

如果变量的值包含空格，则必须将值放在引号中。

```
myvar="hello world"
```

## 3、读取变量

读取变量的时候，直接在变量名前加上`$`就可以了。

```
$ foo=bar
$ echo $foo
bar
```

## 4、删除变量

`unset`命令用来删除一个变量。

```
unset NAME
```

这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使`unset`命令删除了变量，还是可以读取这个变量，值为空字符串。

所以，删除一个变量，也可以将这个变量设成空字符串。

```
$ foo=''
$ foo=
```

上面两种写法，都是删除了变量`foo`。由于不存在的值默认为空字符串，所以后一种写法可以在等号右边不写任何值。

## 5、输出变量，export 命令

用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。

`export`命令用来向子 Shell 输出变量。

```
NAME=foo
export NAME
```

子 Shell 如果修改继承的变量，不会影响父 Shell。

```
# 输出变量 $foo
$ export foo=bar

# 新建子 Shell
$ bash

# 读取 $foo
$ echo $foo
bar

# 修改继承的变量
$ foo=baz

# 退出子 Shell
$ exit

# 读取 $foo
$ echo $foo
bar
```

## 6、特殊变量

Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。

（1）`$?`

`$?`为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是`0`，表示上一个命令执行成功；如果是非零，上一个命令执行失败。

```
$ ls doesnotexist
ls: doesnotexist: No such file or directory

$ echo $?
1
```

（2）`$$`

`$$`为当前 Shell 的进程 ID。

```
$ echo $$
10662
```

这个特殊变量可以用来命名临时文件。

```
LOGFILE=/tmp/output_log.$$
```

（3）`$_`

`$_`为上一个命令的最后一个参数。

```
$ grep dictionary /usr/share/dict/words
dictionary

$ echo $_
/usr/share/dict/words
```

（4）`$!`

`$!`为最近一个后台执行的异步命令的进程 ID。

```
$ firefox &
[1] 11064

$ echo $!
11064
```

上面例子中，`firefox`是后台运行的命令，`$!`返回该命令的进程 ID。

（5）`$0`

`$0`为当前 Shell 的名称（在命令行直接执行时）或者脚本名（在脚本中执行时）。

```
$ echo $0
bash
```

上面例子中，`$0`返回当前运行的是 Bash。

（6）`$-`

`$-`为当前 Shell 的启动参数。

```
$ echo $-
himBHs
```

（7）`$@`和`$#`

`$#`表示脚本的参数数量，`$@`表示脚本的参数值，参见脚本一章。

## 7、declare 命令

`declare`命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。

它的语法形式如下。

```
declare OPTION VARIABLE=value
```

`declare`命令的主要参数（OPTION）如下。

- `-a`：声明数组变量。
- `-f`：输出所有函数定义。
- `-F`：输出所有函数名。
- `-i`：声明整数变量。
- `-l`：声明变量为小写字母。
- `-p`：查看变量信息。
- `-r`：声明只读变量。
- `-u`：声明变量为大写字母。
- `-x`：该变量输出为环境变量。

**（1）`-i`参数**

`-i`参数声明整数变量以后，可以直接进行数学运算。

```
$ declare -i val1=12 val2=5
$ declare -i result
$ result=val1*val2
$ echo $result
60
```

上面例子中，如果变量`result`不声明为整数，`val1*val2`会被当作字面量，不会进行整数运算。另外，`val1`和`val2`其实不需要声明为整数，因为只要`result`声明为整数，它的赋值就会自动解释为整数运算。

注意，一个变量声明为整数以后，依然可以被改写为字符串。

```
$ declare -i var=12
$ var=foo
$ echo $var
0
```

上面例子中，变量`var`声明为整数，覆盖以后，Bash 不会报错，但会赋以不确定的值，上面的例子中可能输出 0，也可能输出的是 3。

**（2）`-x`参数**

`-x`参数等同于`export`命令，可以输出一个变量为子 Shell 的环境变量。

```
$ declare -x foo
# 等同于
$ export foo
```

**（3）`-r`参数**

`-r`参数可以声明只读变量，无法改变变量值，也不能`unset`变量。

```
$ declare -r bar=1

$ bar=2
bash: bar：只读变量
$ echo $?
1

$ unset bar
bash: bar：只读变量
$ echo $?
1
```

上面例子中，后两个赋值语句都会报错，命令执行失败。

**（4）`-u`参数**

`-u`参数声明变量为大写字母，可以自动把变量值转成大写字母。

```
$ declare -u foo
$ foo=upper
$ echo $foo
UPPER
```

**（5）`-l`参数**

`-l`参数声明变量为小写字母，可以自动把变量值转成小写字母。

```
$ declare -l bar
$ bar=LOWER
$ echo $bar
lower
```

**（6）`-p`参数**

`-p`参数输出变量信息。

```
$ foo=hello
$ declare -p foo
declare -- foo="hello"
$ declare -p bar
bar：未找到
```

上面例子中，`declare -p`可以输出已定义变量的值，对于未定义的变量，会提示找不到。

如果不提供变量名，`declare -p`输出所有变量的信息。

```
$ declare -p
```

**（7）`-f`参数**

`-f`参数输出当前环境的所有函数，包括它的定义。

```
$ declare -f
```

**（8）`-F`参数**

`-F`参数输出当前环境的所有函数名，不包含函数定义。

```
$ declare -F
```

## 9、readonly 命令

`readonly`命令等同于`declare -r`，用来声明只读变量，不能改变变量值，也不能`unset`变量。

```
$ readonly foo=1
$ foo=2
bash: foo：只读变量
$ echo $?
1
```

上面例子中，更改只读变量`foo`会报错，命令执行失败。

`readonly`命令有三个参数。

- `-f`：声明的变量为函数名。
- `-p`：打印出所有的只读变量。
- `-a`：声明的变量为数组。

## let 命令

`let`命令声明变量时，可以直接执行算术表达式。

```
$ let foo=1+2
$ echo $foo
3
```

上面例子中，`let`命令可以直接计算`1 + 2`。

# 六、字符串操作

## 1、字符串的长度

获取字符串长度的语法如下。

```
a=qweqwe
echo ${#varname}
6
```

大括号`{}`是必需的，否则 Bash 会将`$#`理解成脚本的参数个数，将变量名理解成文本。

## 2、子字符串

字符串提取子串的语法如下。

```
${varname:offset:length}
```

上面语法的含义是返回变量`$varname`的子字符串，从位置`offset`开始（从`0`开始计算），长度为`length`。

```
$ count=frogfootman
$ echo ${count:4:4}
foot
```

# 七、Bash 的算术运算

## 1、算术表达式

`((...))`语法可以进行整数的算术运算。

```
$ echo $((2 + 2))
4
```

`((...))`语法支持的算术运算符如下。

- `+`：加法
- `-`：减法
- `*`：乘法
- `/`：除法（整除）
- `%`：余数
- `**`：指数
- `++`：自增运算（前缀或后缀）
- `--`：自减运算（前缀或后缀）

注意，除法运算符的返回结果总是整数，比如`5`除以`2`，得到的结果是`2`，而不是`2.5`。

```
$ echo $((5 / 2))
2
```

`$((...))`内部可以用圆括号改变运算顺序。

```
$ echo $(( (2 + 3) * 4 ))
20
```

上面例子中，内部的圆括号让加法先于乘法执行。

这个语法只能计算整数，否则会报错。

```
# 报错
$ echo $((1.5 + 1))
bash: 语法错误
```

如果在`$((...))`里面使用字符串，Bash 会认为那是一个变量名。如果 1.不存在同名变量，2.字符串如果不对应已存在的变量，Bash 就会将其作为空值，因此不会报错。

```
$ echo $(( "hello" + 2))
2
$ foo=hello
$ echo $(( foo + 2))
2
```

最后，`$[...]`是以前的语法，也可以做整数运算，不建议使用。

```
$ echo $[2+2]
4
```

## 2、数值的进制

Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。

- `number`：没有任何特殊表示法的数字是十进制数（以 10 为底）。
- `0number`：八进制数。
- `0xnumber`：十六进制数。
- `base#number`：`base`进制的数。

下面是一些例子。

```
$ echo $((0xff))
255
$ echo $((2#11111111))
255
```

上面例子中，`0xff`是十六进制数，`2#11111111`是二进制数。

## 3、位运算

`$((...))`支持以下的二进制位运算符。

- `<<`：位左移运算，把一个数字的所有位向左移动指定的位。
- `>>`：位右移运算，把一个数字的所有位向右移动指定的位。
- `&`：位的“与”运算，对两个数字的所有位执行一个`AND`操作。
- `|`：位的“或”运算，对两个数字的所有位执行一个`OR`操作。
- `~`：位的“否”运算，对一个数字的所有位取反。
- `^`：位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。

## 4、赋值运算

算术表达式`$((...))`可以执行赋值运算。也可以进行三元运算符

```
$ foo=5
$ echo $((foo*=2))
10
$ echo $(( foo<5 ? foo-1 : foo+1))
6
```

上面例子中，`a=1`对变量`a`进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。

## 5、expr 命令

`expr`命令支持算术运算，可以不使用`((...))`语法。

```
$ expr 3 + 2
5
```

`expr`命令支持变量替换。

```
$ foo=3
$ expr $foo + 2
5
```

`expr`命令也不支持非整数参数。

```
$ expr 3.5 + 2
expr: 非整数参数
```

上面例子中，如果有非整数的运算，`expr`命令就报错了。

数的运算，`expr`命令就报错了。

## 6、let 命令

`let`命令用于将算术运算的结果，赋予一个变量。

```
$ let x=2+3
$ echo $x
5
```

# 八、快捷键

Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能 sh 就不带有行操作功能。

## 1、光标移动

Readline 提供快速移动光标的快捷键。

- `Ctrl + a`：移到行首。
- `Ctrl + b`：向行首移动一个字符，与左箭头作用相同。
- `Ctrl + e`：移到行尾。
- `Ctrl + f`：向行尾移动一个字符，与右箭头作用相同。
- `Alt + f`：移动到当前单词的词尾。
- `Alt + b`：移动到当前单词的词首。

## 2、编辑操作

下面的快捷键可以编辑命令行内容。

- `Ctrl + l`快捷键可以清除屏幕，即将当前行移到屏幕的第一行，与`clear`命令作用相同。

- `Ctrl + d`：删除光标位置的字符（delete）。
- `Ctrl + w`：删除光标前面的单词。
- `Ctrl + t`：光标位置的字符与它前面一位的字符交换位置（transpose）。
- `Alt + t`：光标位置的词与它前面一位的词交换位置（transpose）。
- `Alt + l`：将光标位置至词尾转为小写（lowercase）。
- `Alt + u`：将光标位置至词尾转为大写（uppercase）。

使用`Ctrl + d`的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。

剪切和粘贴快捷键如下。

- `Ctrl + k`：剪切光标位置到行尾的文本。
- `Ctrl + u`：剪切光标位置到行首的文本。
- `Alt + d`：剪切光标位置到词尾的文本。
- `Alt + Backspace`：剪切光标位置到词首的文本。
- `Ctrl + y`：在光标位置粘贴文本。

## 3、自动补全

- Tab：完成自动补全。
- `Ctrl + x /`：先按`Ctrl + x`，再按`/`，等同于`Alt + ?`，列出可能的文件路径补全。
- `Ctrl + x !`：先按`Ctrl + x`，再按`!`，等同于`Alt + !`，命令补全。
- `Ctrl + x ~`：先按`Ctrl + x`，再按`~`，等同于`Alt + ~`，用户名补全。
  - `Ctrl + x $`：先按`Ctrl + x`，再按`$`，等同于`Alt + $`，变量名补全。
- `Ctrl + x @`：先按`Ctrl + x`，再按`@`，等同于`Alt + @`，主机名补全。
- `Alt + !`：命令补全。
- `Alt + @`：主机名补全。
- `Alt + ?`：列出可能的补全，与连按两次 Tab 键作用相同。
- `Alt + /`：尝试文件路径补全。
- `Alt + $`：变量名补全。
- `Alt + ~`：用户名补全。
- `Alt + *`：在命令行一次性插入所有可能的补全。
- `Alt + Tab`：尝试用`.bash_history`里面以前执行命令，进行补全。

## 4、操作历史

`history`命令会输出这个文件的全部内容。用户可以看到最近执行过的所有命令，每条命令之前都有行号。越近的命令，排在越后面。

```
$ history
...
498 echo Goodbye
499 ls ~
500 cd
```

输入命令时，按下`Ctrl + r`快捷键，就可以搜索操作历史，选择以前执行过的命令。这时键入命令的开头部分，Shell 就会自动在历史文件中，查询并显示最近一条匹配的结果，这时按下回车键，就会执行那条命令。

`!echo`会执行最近一条以`echo`开头的命令。注意，`!string`语法只会匹配命令，不会匹配参数。所以`!echo H`不会执行`echo Hello World`，而是会执行`echo Goodbye`，并把参数`H`附加在这条命令之后。同理，`!echo H G`也是等同于`echo Goodbye`命令之后附加`H G`。

由于`!string`语法会扩展成以前执行过的命令，所以含有`!`的字符串放在双引号里面，必须非常小心，如果它后面有非空格的字符，就很有可能报错。

```
$ echo "I say:\"hello!\""
bash: !\: event not found
```

上面的命令会报错，原因是感叹号后面是一个反斜杠，Bash 会尝试寻找，以前是否执行过反斜杠开头的命令，一旦找不到就会报错。解决方法就是在感叹号前面，也加上反斜杠。

```
$ echo "I say:\"hello\!\""
I say:"hello\!"
```

## 5、history 命令

前面说过，`history`命令能显示操作历史，即`.bash_history`文件的内容。

```
$ history
```

使用该命令，而不是直接读取`.bash_history`文件的好处是，它会在所有的操作前加上行号，最近的操作在最后面，行号最大。

通过定制环境变量`HISTTIMEFORMAT`，可以显示每个操作的时间。

```
$ export HISTTIMEFORMAT='%F %T  '
$ history
1  2013-06-09 10:40:12   cat /etc/issue
2  2013-06-09 10:40:12   clear
```

上面代码中，`%F`相当于`%Y - %m - %d`，`%T`相当于`%H : %M : %S`。

只要设置`HISTTIMEFORMAT`这个环境变量，就会在`.bash_history`文件保存命令的执行时间戳。如果不设置，就不会保存时间戳。

环境变量`HISTSIZE`设置保存历史操作的数量。

```
$ export HISTSIZE=10000
```

上面命令设置保存过去 10000 条操作历史。

如果不希望保存本次操作的历史，可以设置`HISTSIZE`等于 0。

```
export HISTSIZE=0
```

如果`HISTSIZE=0`写入用户主目录的`~/.bashrc`文件，那么就不会保留该用户的操作历史。如果写入`/etc/profile`，整个系统都不会保留操作历史。

环境变量`HISTIGNORE`可以设置哪些命令不写入操作历史。

```
export HISTIGNORE='pwd:ls:exit'
```

上面示例设置，`pwd`、`ls`、`exit`这三个命令不写入操作历史。

如果想搜索某个以前执行的命令，可以配合`grep`命令搜索操作历史。

```
$ history | grep /usr/bin
```

上面命令返回`.bash_history`文件里面，那些包含`/usr/bin`的命令。

操作历史的每一条记录都有编号。知道了命令的编号以后，可以用`感叹号 + 编号`执行该命令。如果想要执行`.bash_history`里面的第 8 条命令，可以像下面这样操作。

```
$ !8
```

`history`命令的`-c`参数可以清除操作历史。

```
$ history -c
```

## 6、相关快捷键

下面是一些与操作历史相关的快捷键。

- `Ctrl + o`：执行历史文件里面的当前条目，并自动显示下一条命令。这对重复执行某个序列的命令很有帮助。

感叹号`!`的快捷键如下。

- `!!`：执行上一个命令。
- `!n`：`n`为数字，执行历史文件里面行号为`n`的命令。
- `!-n`：执行当前命令之前`n`条的命令。
- `!string`：执行最近一个以指定字符串`string`开头的命令。
- `!?string`：执行最近一条包含字符串`string`的命令。
- `!$`：代表上一个命令的最后一个参数。
- `!*`：代表上一个命令的所有参数，即除了命令以外的所有部分。
- `^string1^string2`：执行最近一条包含`string1`的命令，将其替换成`string2`。

如果希望确定是什么命令，然后再执行，可以打开`histverify`选项。这样的话，使用`!`快捷键所产生的命令，会先打印出来，等到用户按下回车键后再执行。

```
$ shopt -s histverify
```

## 7、其他快捷键

- `Alt + .`：插入上一个命令的最后一个词。

上面的`Alt + .`快捷键，对于很长的文件路径，有时会非常方便。因为 Unix 命令的最后一个参数通常是文件路径。

```
$ mkdir foo_bar
$ cd #按下 Alt + .
```

上面例子中，在`cd`命令后按下`Alt + .`，就会自动插入`foo_bar`。

# 九、目录堆栈

## 1、cd -

Bash 可以记忆用户进入过的目录。默认情况下，只记忆前一次所在的目录，`cd -`命令可以返回前一次的目录。

```
# 当前目录是 /path/to/foo
$ cd bar

# 重新回到 /path/to/foo
$ cd -
```

## 2、pushd，popd

如果希望记忆多重目录，可以使用`pushd`命令和`popd`命令。它们用来操作目录堆栈。

`pushd`命令的用法类似`cd`命令，可以进入指定的目录。

```
$ pushd dirname
```

上面命令会进入目录`dirname`，并将该目录放入堆栈。

每次使用`pushd`命令，都会将所要进入的目录，放在堆栈的顶部。

`popd`命令不带有参数时，会移除堆栈的顶部记录，并进入新的堆栈顶部目录（即原来的第二条目录）。

这两个命令的参数如下。

**（1）-n 参数**

`-n`的参数表示仅操作堆栈，不改变目录。

```
$ popd -n
```

上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。

**（2）整数参数**

这两个命令还可以接受一个整数作为参数，该整数表示堆栈中指定位置的记录（从 0 开始），作为操作对象。这时不会切换目录。

```
# 从栈顶算起的3号目录（从0开始），移动到栈顶
$ pushd +3

# 从栈底算起的3号目录（从0开始），移动到栈顶
$ pushd -3

# 删除从栈顶算起的3号目录（从0开始）
$ popd +3

# 删除从栈底算起的3号目录（从0开始）
$ popd -3
```

上面例子的整数编号都是从 0 开始计算，`popd +0`是删除第一个目录，`popd +1`是删除第二个，`popd -0`是删除最后一个目录，，`popd -1`是删除倒数第二个。

**（3）目录参数**

`pushd`可以接受一个目录作为参数，表示将该目录放到堆栈顶部，并进入该目录。

```
$ pushd dir
```

`popd`没有这个参数。

## dirs 命令

`dirs`命令可以显示目录堆栈的内容，一般用来查看`pushd`和`popd`操作后的结果。

```
$ dirs
```

它有以下参数。

- `-c`：清空目录栈。
- `-l`：用户主目录不显示波浪号前缀，而打印完整的目录。
- `+N`：`N`为整数，表示显示堆顶算起的第 N 个目录，从零开始。
- `-N`：`N`为整数，表示显示堆底算起的第 N 个目录，从零开始。

# 十、Bash 脚本入门

## 1、Shebang 行

脚本的第一行通常是指定解释器，这一行以`#!`字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。

`#!`后面就是脚本解释器的位置，Bash 脚本的解释器一般是`/bin/sh`或`/bin/bash`。

```
#!/bin/sh
#!/bin/bash
```

`#!`与脚本解释器之间有没有空格，都是可以的。

如果 Bash 解释器不放在目录`/bin`，脚本就无法执行了。为了保险，可以写成下面这样。

```
#!/usr/bin/env bash
```

上面命令使用`env`命令（这个命令总是在`/usr/bin`目录），返回 Bash 可执行文件的位置。`env`命令的详细介绍，请看后文。

Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是`script.sh`，有 Shebang 行的时候，可以直接调用执行。

```
$ ./script.sh
```

上面例子中，`script.sh`是脚本文件名。脚本通常使用`.sh`后缀名，不过这不是必需的。

如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。

```
$ /bin/sh ./script.sh
# 或者
$ bash ./script.sh
```

## 2、执行权限和路径

前面说过，只要指定了 Shebang 行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。

```
# 给所有用户执行权限
$ chmod +x script.sh

# 给所有用户读权限和执行权限
$ chmod +rx script.sh
# 或者
$ chmod 755 script.sh

# 只给脚本拥有者读权限和执行权限
$ chmod u+rx script.sh
```

脚本的权限通常设为`755`（拥有者有所有权限，其他人有读和执行权限）或者`700`（只有拥有者可以执行）。

除了执行权限，脚本调用时，一般需要指定脚本的路径（比如`path/script.sh`）。如果将脚本放在环境变量`$PATH`指定的目录中，就不需要指定路径了。因为 Bash 会自动到这些目录中，寻找是否存在同名的可执行文件。

建议在主目录新建一个`~/bin`子目录，专门存放可执行脚本，然后把`~/bin`加入`$PATH`。

```
export PATH=$PATH:~/bin
```

上面命令改变环境变量`$PATH`，将`~/bin`添加到`$PATH`的末尾。可以将这一行加到`~/.bashrc`文件里面，然后重新加载一次`.bashrc`，这个配置就可以生效了。

```
$ source ~/.bashrc
```

以后不管在什么目录，直接输入脚本文件名，脚本就会执行。

```
$ script.sh
```

上面命令没有指定脚本路径，因为`script.sh`在`$PATH`指定的目录中。

## 3、env 命令

`env`命令总是指向`/usr/bin/env`文件，或者说，这个二进制文件总是在目录`/usr/bin`。

`#!/usr/bin/env NAME`这个语法的意思是，让 Shell 查找`$PATH`环境变量里面第一个匹配的`NAME`。如果你不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。

`/usr/bin/env bash`的意思就是，返回`bash`可执行文件的位置，前提是`bash`的路径是在`$PATH`里面。其他脚本文件也可以使用这个命令。比如 Node.js 脚本的 Shebang 行，可以写成下面这样。

```
#!/usr/bin/env node
```

`env`命令的参数如下。

- `-i`, `--ignore-environment`：不带环境变量启动。
- `-u`, `--unset=NAME`：从环境变量中删除一个变量。
- `--help`：显示帮助。
- `--version`：输出版本信息。

下面是一个例子，新建一个不带任何环境变量的 Shell。

```
$ env -i /bin/sh
```

## 注释

4、Bash 脚本中，`#`表示注释，可以放在行首，也可以放在行尾。

```
# 本行是注释
echo 'Hello World!'

echo 'Hello World!' # 井号后面的部分也是注释
```

建议在脚本开头，使用注释说明当前脚本的作用，这样有利于日后的维护。

## 4、脚本参数

调用脚本的时候，脚本文件名后面可以带有参数。

```
$ script.sh word1 word2 word3
```

上面例子中，`script.sh`是一个脚本文件，`word1`、`word2`和`word3`是三个参数。

脚本文件内部，可以使用特殊变量，引用这些参数。

- `$0`：脚本文件名，即`script.sh`。
- `$1`~`$9`：对应脚本的第一个参数到第九个参数。
- `$#`：参数的总数。
- `$@`：全部的参数，参数之间使用空格分隔。

如果脚本的参数多于 9 个，那么第 10 个参数可以用`${10}`的形式引用，以此类推。

注意，如果命令是`command -o foo bar`，那么`-o`是`$1`，`foo`是`$2`，`bar`是`$3`。

下面是一个脚本内部读取命令行参数的例子。

```
#!/bin/bash
# script.sh

echo "全部参数：" $@
echo "命令行参数数量：" $#
echo '$0 = ' $0
echo '$1 = ' $1
echo '$2 = ' $2
echo '$3 = ' $3
```

执行结果如下。

```
$ ./script.sh a b c
全部参数：a b c
命令行参数数量：3
$0 =  script.sh
$1 =  a
$2 =  b
$3 =  c
```

用户可以输入任意数量的参数，利用`for`循环，可以读取每一个参数。

```
#!/bin/bash

for i in "$@"; do
  echo $i
done
```

上面例子中，`$@`返回一个全部参数的列表，然后使用`for`循环遍历。

如果多个参数放在双引号里面，视为一个参数。

```
$ ./script.sh "a b"
```

上面例子中，Bash 会认为`"a b"`是一个参数，`$1`会返回`a b`。注意，返回时不包括双引号。

## 5、shift 命令

`shift`命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数（`$1`），使得后面的参数向前一位，即`$2`变成`$1`、`$3`变成`$2`、`$4`变成`$3`，以此类推。

`shift`命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为`1`。

```
shift 3
```

上面的命令移除前三个参数，原来的`$4`变成`$1`。

## 6、配置项参数终止符 `--`

`-`和`--`开头的参数，会被 Bash 当作配置项解释。但是，有时它们不是配置项，而是实体参数的一部分，比如文件名叫做`-f`或`--file`。

```
$ cat -f
$ cat --file
```

上面命令的原意是输出文件`-f`和`--file`的内容，但是会被 Bash 当作配置项解释。

这是就可以使用配置项参数终止符`--`，它的作用是告诉 Bash，在它后面的参数开头的`-`和`--`不是配置项，只能当作实体参数解释。

```
$ cat -- -f
$ cat -- --file
```

上面命令可以正确展示文件`-f`和`--file`的内容，因为它们放在`--`的后面，开头的`-`和`--`就不再当作配置项解释了。

如果要确保某个变量不会被当作配置项解释，就要在它前面放上参数终止符`--`。

```
$ ls -- $myPath
```

上面示例中，`--`强制变量`$myPath`只能当作实体参数（即路径名）解释。如果变量不是路径名，就会报错。

```
$ myPath="-l"
$ ls -- $myPath
ls: 无法访问'-l': 没有那个文件或目录
```

上面例子中，变量`myPath`的值为`-l`，不是路径。但是，`--`强制`$myPath`只能作为路径解释，导致报错“不存在该路径”。

下面是另一个实际的例子，如果想在文件里面搜索`--hello`，这时也要使用参数终止符`--`。

```
$ grep -- "--hello" example.txt
```

上面命令在`example.txt`文件里面，搜索字符串`--hello`。这个字符串是`--`开头，如果不用参数终止符，`grep`命令就会把`--hello`当作配置项参数，从而报错。

## 7、exit 命令

`exit`命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。

```
$ exit
```

上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。

`exit`命令后面可以跟参数，该参数就是退出状态。

```
# 退出值为0（成功）
$ exit 0

# 退出值为1（失败）
$ exit 1
```

退出时，脚本会返回一个退出值。脚本的退出值，`0`表示正常，`1`表示发生错误，`2`表示用法不对，`126`表示不是可执行脚本，`127`表示命令没有发现。如果脚本被信号`N`终止，则退出值为`128 + N`。简单来说，只要退出值非 0，就认为执行出错。

下面是一个例子。

```
if [ $(id -u) != "0" ]; then
  echo "根用户才能执行当前脚本"
  exit 1
fi
```

上面的例子中，`id -u`命令返回用户的 ID，一旦用户的 ID 不等于`0`（根用户的 ID），脚本就会退出，并且退出码为`1`，表示运行失败。

`exit`与`return`命令的差别是，`return`命令是函数的退出，并返回一个值给调用者，脚本依然执行。`exit`是整个脚本的退出，如果在函数之中调用`exit`，则退出函数，并终止脚本执行。

## 8、命令执行结果

命令执行结束后，会有一个返回值。`0`表示执行成功，非`0`（通常是`1`）表示执行失败。环境变量`$?`可以读取前一个命令的返回值。

利用这一点，可以在脚本中对命令执行结果进行判断。

```
cd $some_directory
if [ "$?" = "0" ]; then
  rm *
else
  echo "无法切换目录！" 1>&2
  exit 1
fi
```

上面例子中，`cd $some_directory`这个命令如果执行成功（返回值等于`0`），就删除该目录里面的文件，否则退出脚本，整个脚本的返回值变为`1`，表示执行失败。

更简洁的写法是利用两个逻辑运算符`&&`（且）和`||`（或）。

```
# 第一步执行成功，才会执行第二步
cd $some_directory && rm *

# 第一步执行失败，才会执行第二步
cd $some_directory || exit 1
```

## 9、source 命令

`source`命令用于执行一个脚本，通常用于重新加载一个配置文件。

```
$ source .bashrc
```

`source`命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，`source`命令执行脚本时，不需要`export`变量。

```
#!/bin/bash
# test.sh
echo $foo
```

上面脚本输出`$foo`变量的值。

```
# 当前 Shell 新建一个变量 foo
$ foo=1

# 打印输出 1
$ source test.sh
1

# 打印输出空字符串
$ bash test.sh
```

上面例子中，当前 Shell 的变量`foo`并没有`export`，所以直接执行无法读取，但是`source`执行可以读取。

`source`命令的另一个用途，是在脚本内部加载外部库。

```
#!/bin/bash

source ./lib.sh

function_from_lib
```

`source`有一个简写形式，可以使用一个点（`.`）来表示。

```
$ . .bashrc
```

## 10、别名，alias 命令

`alias`命令用来为一个命令指定别名，这样更便于记忆。下面是`alias`的格式。

```
alias NAME=DEFINITION
```

上面命令中，`NAME`是别名的名称，`DEFINITION`是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。

一个常见的例子是为`grep`命令起一个`search`的别名。

```
alias search=grep
```

`alias`也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个`today`的命令。

```
$ alias today='date +"%A, %B %-d, %Y"'
$ today
星期一, 一月 6, 2020
```

有时为了防止误删除文件，可以指定`rm`命令的别名。

```
$ alias rm='rm -i'
```

上面命令指定`rm`命令是`rm -i`，每次删除文件之前，都会让用户确认。

`alias`定义的别名也可以接受参数，参数会直接传入原始命令。

```
$ alias echo='echo It says: '
$ echo hello world
It says: hello world
```

上面例子中，别名定义了`echo`命令的前两个参数，等同于修改了`echo`命令的默认行为。

指定别名以后，就可以像使用其他命令一样使用别名。一般来说，都会把常用的别名写在`~/.bashrc`的末尾。另外，只能为命令定义别名，为其他部分（比如很长的路径）定义别名是无效的。

直接调用`alias`命令，可以显示所有别名。

```
$ alias
```

`unalias`命令可以解除别名。

```
$ unalias lt
```

# 十一、read 命令

## 1、用法

有时，脚本需要在执行过程中，由用户提供一部分数据，这时可以使用`read`命令。它将用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。

`read`命令的格式如下。

```
read [-options] [variable...]
```

上面语法中，`options`是参数选项，`variable`是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量`REPLY`会包含用户输入的一整行数据。

下面是一个例子`demo.sh`。

```
#!/bin/bash

echo -n "输入一些文本 > "
read text
echo "你的输入：$text"
```

上面例子中，先显示一行提示文本，然后会等待用户输入文本。用户输入的文本，存入变量`text`，在下一行显示出来。

```
$ bash demo.sh
输入一些文本 > 你好，世界
你的输入：你好，世界
```

`read`可以接受用户输入的多个值。

```
#!/bin/bash
echo Please, enter your firstname and lastname
read FN LN
echo "Hi! $LN, $FN !"
```

上面例子中，`read`根据用户的输入，同时为两个变量赋值。

如果用户的输入项少于`read`命令给出的变量数目，那么额外的变量值为空。如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。

如果`read`命令之后没有定义变量名，那么环境变量`REPLY`会包含所有的输入。

```
#!/bin/bash
# read-single: read multiple values into default variable
echo -n "Enter one or more values > "
read
echo "REPLY = '$REPLY'"
```

上面脚本的运行结果如下。

```
$ read-single
Enter one or more values > a b c d
REPLY = 'a b c d'
```

`read`命令除了读取键盘输入，可以用来读取文件。

```
#!/bin/bash

filename='/etc/hosts'

while read myline
do
  echo "$myline"
done < $filename
```

上面的例子通过`read`命令，读取一个文件的内容。`done`命令后面的定向符`<`，将文件内容导向`read`命令，每次读取一行，存入变量`myline`，直到文件读取完毕。

## 参数

`read`命令的参数如下。

**（1）-t 参数**

`read`命令的`-t`参数，设置了超时的秒数。如果超过了指定时间，用户仍然没有输入，脚本将放弃等待，继续向下执行。

```
#!/bin/bash

echo -n "输入一些文本 > "
if read -t 3 response; then
  echo "用户已经输入了"
else
  echo "用户没有输入"
fi
```

上面例子中，输入命令会等待 3 秒，如果用户超过这个时间没有输入，这个命令就会执行失败。`if`根据命令的返回值，转入`else`代码块，继续往下执行。

环境变量`TMOUT`也可以起到同样作用，指定`read`命令等待用户输入的时间（单位为秒）。

```
$ TMOUT=3
$ read response
```

上面例子也是等待 3 秒，如果用户还没有输入，就会超时。

**（2）-p 参数**

`-p`参数指定用户输入的提示信息。

```
read -p "Enter one or more values > "
echo "REPLY = '$REPLY'"
```

上面例子中，先显示`Enter one or more values >`，再接受用户的输入。

**（3）-a 参数**

`-a`参数把用户的输入赋值给一个数组，从零号位置开始。

```
$ read -a people
alice duchess dodo
$ echo ${people[2]}
dodo
```

上面例子中，用户输入被赋值给一个数组`people`，这个数组的 2 号成员就是`dodo`。

**（4）-n 参数**

`-n`参数指定只读取若干个字符作为变量值，而不是整行读取。

```
$ read -n 3 letter
abcdefghij
$ echo $letter
abc
```

上面例子中，变量`letter`只包含 3 个字母。

**（5）-e 参数**

`-e`参数允许用户输入的时候，使用`readline`库提供的快捷键，比如自动补全。具体的快捷键可以参阅《行操作》一章。

```
#!/bin/bash

echo Please input the path to the file:

read -e fileName

echo $fileName
```

上面例子中，`read`命令接受用户输入的文件名。这时，用户可能想使用 Tab 键的文件名“自动补全”功能，但是`read`命令的输入默认不支持`readline`库的功能。`-e`参数就可以允许用户使用自动补全。

**（6）其他参数**

- `-d delimiter`：定义字符串`delimiter`的第一个字符作为用户输入的结束，而不是一个换行符。
- `-r`：raw 模式，表示不把用户输入的反斜杠字符解释为转义字符。
- `-s`：使得用户的输入不显示在屏幕上，这常常用于输入密码或保密信息。
- `-u fd`：使用文件描述符`fd`作为输入。

## IFS 变量

`read`命令读取的值，默认是以空格分隔。可以通过自定义环境变量`IFS`（内部字段分隔符，Internal Field Separator 的缩写），修改分隔标志。

`IFS`的默认值是空格、Tab 符号、换行符号，通常取第一个（即空格）。

如果把`IFS`定义成冒号（`:`）或分号（`;`），就可以分隔以这两个符号分隔的值，这对读取文件很有用。

```
#!/bin/bash
# read-ifs: read fields from a file

FILE=/etc/passwd

read -p "Enter a username > " user_name
file_info="$(grep "^$user_name:" $FILE)"

if [ -n "$file_info" ]; then
  IFS=":" read user pw uid gid name home shell <<< "$file_info"
  echo "User = '$user'"
  echo "UID = '$uid'"
  echo "GID = '$gid'"
  echo "Full Name = '$name'"
  echo "Home Dir. = '$home'"
  echo "Shell = '$shell'"
else
  echo "No such user '$user_name'" >&2
  exit 1
fi
```

上面例子中，`IFS`设为冒号，然后用来分解`/etc/passwd`文件的一行。`IFS`的赋值命令和`read`命令写在一行，这样的话，`IFS`的改变仅对后面的命令生效，该命令执行后`IFS`会自动恢复原来的值。如果不写在一行，就要采用下面的写法。

```
OLD_IFS="$IFS"
IFS=":"
read user pw uid gid name home shell <<< "$file_info"
IFS="$OLD_IFS"
```

另外，上面例子中，`<<<`是 Here 字符串，用于将变量值转为标准输入，因为`read`命令只能解析标准输入。

如果`IFS`设为空字符串，就等同于将整行读入一个变量。

```
#!/bin/bash
input="/path/to/txt/file"
while IFS= read -r line
do
  echo "$line"
done < "$input"
```

上面的命令可以逐行读取文件，每一行存入变量`line`，打印出来以后再读取下一行。
