---
order: 1
---

# LeetCode p1-p100

## p1-p10

## p11-p20

### 19. 删除链表的倒数第 N 个结点

[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?q=javasc&orderBy=most_relevant)

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

`思路(快慢指针)`:快的指针先走 n 步，快慢指针再一起走`总量-n`，得到倒数第 n 步。

```ts
var removeNthFromEnd = function (head, n) {
  let current = new ListNode(null, head);
  let i = 0;
  let quick = current;
  let slow = current;
  // 快的先走n步
  while (i++ <= n) {
    quick = quick.next;
  }
  while (quick != null) {
    quick = quick.next;
    slow = slow.next;
  }
  slow.next = slow.next.next;
  return current.next;
};
```

## p51-p60

### 58. 最后一个单词的长度

[58. 最后一个单词的长度](https://leetcode.cn/problems/length-of-last-word/description/)

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

```text
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为5。
```

`思路(暴力枚举)`:用去空串偏差指针优化,从字符串非空尾部往前遍历，遇到空串截止。

时间复杂度：最坏情况为 O(N)

空间复杂度：O(1)

```c
class Solution {
public:
    int lengthOfLastWord(string s) {
        int length = s.length();
        int offsetIndex = 1;
        while(s[length - offsetIndex] == ' '){
            offsetIndex++;
        }
        int index = 0;
        //增加去空串偏差值
        while(index + offsetIndex <= length){
            if(s[length - index - offsetIndex] == ' ') return index;
            index++;
        }
        return index;
    }
};
```

## p61-p70

### 61. 旋转链表

[61. 旋转链表](https://leetcode.cn/problems/rotate-list/description/)

给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。

```text
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

`思路(循环链表)`:先将链表最后一位指向 head 结点，构建循环链表。记录链表长度 n，将循环链表右移`n - (k % n)`位，再断开循环链表即可。

时间复杂度：最坏情况为 O(N)，最坏情况下，我们需要遍历该链表两次

空间复杂度：O(1)，我们只需要常数的空间存储若干变量。

```c
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(head == nullptr || head->next == nullptr || k == 0) return head;
        ListNode* circulate = head;
        int n = 1;
        while(circulate->next != nullptr){
            circulate = circulate->next;
            n++;
        }
        int split = n - (k % n);
        if(split == n) return head;
        circulate->next = head;
        while(split--){     //头结点指向往后移split个
            circulate = circulate->next;
        }
        ListNode* res = circulate->next;
        circulate->next = nullptr;  //断开循环链表
        return res;
    }
};
```
