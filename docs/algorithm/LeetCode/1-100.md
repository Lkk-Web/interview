---
order: 1
---

# LeetCode p1-p100

## p1-p10

## p11-p20

### 19. 删除链表的倒数第 N 个结点

[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?q=javasc&orderBy=most_relevant)

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

`思路(快慢指针)`:快的指针先走 n 步，快慢指针再一起走`总量-n`，得到倒数第 n 步。

```ts
var removeNthFromEnd = function (head, n) {
  let current = new ListNode(null, head);
  let i = 0;
  let quick = current;
  let slow = current;
  // 快的先走n步
  while (i++ <= n) {
    quick = quick.next;
  }
  while (quick != null) {
    quick = quick.next;
    slow = slow.next;
  }
  slow.next = slow.next.next;
  return current.next;
};
```

## p51-p60

### 58. 最后一个单词的长度

[58. 最后一个单词的长度](https://leetcode.cn/problems/length-of-last-word/description/)

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

```text
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为5。
```

`思路(暴力枚举)`:用去空串偏差指针优化,从字符串非空尾部往前遍历，遇到空串截止。

时间复杂度：最坏情况为 O(N)

空间复杂度：O(1)

```c
class Solution {
public:
    int lengthOfLastWord(string s) {
        int length = s.length();
        int offsetIndex = 1;
        while(s[length - offsetIndex] == ' '){
            offsetIndex++;
        }
        int index = 0;
        //增加去空串偏差值
        while(index + offsetIndex <= length){
            if(s[length - index - offsetIndex] == ' ') return index;
            index++;
        }
        return index;
    }
};
```

## p61-p70

### 61. 旋转链表

[61. 旋转链表](https://leetcode.cn/problems/rotate-list/description/)

给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。

```text
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

`思路(循环链表)`:先将链表最后一位指向 head 结点，构建循环链表。记录链表长度 n，将循环链表右移`n - (k % n)`位，再断开循环链表即可。

时间复杂度：最坏情况为 O(N)，最坏情况下，我们需要遍历该链表两次

空间复杂度：O(1)，我们只需要常数的空间存储若干变量。

```c
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(head == nullptr || head->next == nullptr || k == 0) return head;
        ListNode* circulate = head;
        int n = 1;
        while(circulate->next != nullptr){
            circulate = circulate->next;
            n++;
        }
        int split = n - (k % n);
        if(split == n) return head;
        circulate->next = head;
        while(split--){     //头结点指向往后移split个
            circulate = circulate->next;
        }
        ListNode* res = circulate->next;
        circulate->next = nullptr;  //断开循环链表
        return res;
    }
};
```

### 66. 加一

[66. 加一](https://leetcode.cn/problems/plus-one/description/)

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

```text
输入：digits = [1,2,9]
输出：[1,3,0]
解释：输入数组表示数字 129.
```

`思路(模拟人工加法)`:由于只需加 1，故只需特判 9 进行数组前移后加 1 即可，若全为 9 则需新开一个数组置第一个为 1，其余为 0。

时间复杂度：最坏情况为 O(N)，最坏情况下，我们需要遍历该数组。

空间复杂度：O(1)，我们只需要常数的空间存储若干变量。

```c
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int length = digits.size();
        int mark = 1;
        while(digits[length - mark] == 9){
            digits[length - mark] = 0;
            if(mark == length){
                vector<int> res(length + 1);
                res[0] = 1;
                return res;
            }
            mark++;
        }
        digits[length - mark] = digits[length - mark] + 1;
        return digits;
    }
};
```
