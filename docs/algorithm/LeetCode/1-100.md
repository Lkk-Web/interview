---
order: 1
---

# LeetCode p1-p100

## p1-p10

## p11-p20

### 19. 删除链表的倒数第 N 个结点

[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?q=javasc&orderBy=most_relevant)

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

`思路(快慢指针)`:快的指针先走 n 步，快慢指针再一起走`总量-n`，得到倒数第 n 步。

```ts
var removeNthFromEnd = function (head, n) {
  let current = new ListNode(null, head);
  let i = 0;
  let quick = current;
  let slow = current;
  // 快的先走n步
  while (i++ <= n) {
    quick = quick.next;
  }
  while (quick != null) {
    quick = quick.next;
    slow = slow.next;
  }
  slow.next = slow.next.next;
  return current.next;
};
```

## p51-p60

### 58. 最后一个单词的长度

[58. 最后一个单词的长度](https://leetcode.cn/problems/length-of-last-word/description/)

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

```text
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为5。
```

`思路(暴力枚举)`:用去空串偏差指针优化,从字符串非空尾部往前遍历，遇到空串截止。

时间复杂度：最坏情况为 O(N)

空间复杂度：O(1)

```c
class Solution {
public:
    int lengthOfLastWord(string s) {
        int length = s.length();
        int offsetIndex = 1;
        while(s[length - offsetIndex] == ' '){
            offsetIndex++;
        }
        int index = 0;
        //增加去空串偏差值
        while(index + offsetIndex <= length){
            if(s[length - index - offsetIndex] == ' ') return index;
            index++;
        }
        return index;
    }
};
```
